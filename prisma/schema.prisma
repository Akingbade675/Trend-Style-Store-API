// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum Role {
  CUSTOMER
  ADMIN
}

enum MediaFolder {
  banners
  brands
  categories
  products
  users
}

// --- User and Auth Related Models ---

model User {
  id                   String         @id @default(auto()) @map("_id") @db.ObjectId
  email                String         @unique
  password             String
  username             String         @unique
  firstName            String
  lastName             String
  phoneNumber          String?
  role                 Role           @default(CUSTOMER)
  isEmailVerified      Boolean        @default(false)
  verificationToken    String?        
  passwordResetToken   String?        
  passwordResetExpires DateTime?

  createdAt            DateTime       @default(now()) @map("created_at")
  updatedAt            DateTime       @updatedAt @map("updated_at")

  avatarId             String?        @db.ObjectId
  avatar               Media?         @relation("UserAvatar", fields: [avatarId], references: [id], onDelete: SetNull)

  // Relations
  orders               Order[]
  reviews              UserReview[]
  addresses            UserAddress[]
  refreshTokens        RefreshToken[]
}

model RefreshToken {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  token         String   @unique
  lookupHash    String   @unique
  userId        String   @db.ObjectId
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  family        String    // To track token lineage
  used          Boolean   @default(false)
  invalidated   Boolean   @default(false)
  expiresAt     DateTime
  createdAt     DateTime  @default(now())
  replacedBy    String?   // Reference to the next token in the chain
  
  // Optional: Add these fields for enhanced security
  userAgent String?
  ipAddress String?
}

model UserAddress {
  id            String  @id @default(auto()) @map("_id") @db.ObjectId
  addressLine1  String
  addressLine2  String? 
  phoneNumber   String? 
  city          String
  region        String? // State/Province
  postalCode    String? 
  isDefault     Boolean @default(false)

  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")

  userId        String  @db.ObjectId
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  countryId     String  @db.ObjectId
  country       Country @relation(fields: [countryId], references: [id])

  @@index([userId])
  @@index([countryId])
}

model Country {
  id            String  @id @default(auto()) @map("_id") @db.ObjectId
  countryName   String  @unique

  addresses     UserAddress[]
}

model Media {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  url       String   // Public URL of the stored file (e.g., S3 URL, Cloudinary URL, local static path)
  altText   String?  // Alt text for accessibility
  filename  String   // Original filename
  mimeType  String?  // e.g., 'image/jpeg', 'image/png'
  size      Int?     // Size in bytes
  folder    MediaFolder?  // Folder categorization (e.g., 'products', 'brands', 'banners', 'categories') - use an Enum potentially
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optional: Track uploader
  // uploadedByUserId String? @db.ObjectId
  // uploadedBy User? @relation("UploadedMedia", fields: [uploadedByUserId], references: [id], onDelete: SetNull)

  // Inverse relations (shows where this media item is used) - useful for checking before deletion
  productImages       ProductImage[]
  productItemImages   ProductItemImage[]
  banners             Banner[]
  categoryImage       Category[]            @relation("CategoryImage")
  brandLogos          Brand[]               @relation("BrandLogo")
  userAvatars         User[]                @relation("UserAvatar")
  
  @@index([folder])
  @@index([filename])
}

// --- Product Related Models ---

model Category {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  name          String      @unique
  description   String?
  isFeatured    Boolean     @default(false)

  imageId       String?     @db.ObjectId
  image         Media?      @relation("CategoryImage", fields: [imageId], references: [id], onDelete: SetNull)

  // Self-relation for subcategories
  parentId      String?     @db.ObjectId
  parent        Category?   @relation("SubCategories", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children      Category[]  @relation("SubCategories")

  // Relations
  brands        BrandCategory[]
  products      ProductCategory[]

  @@index([parentId])
}

model Banner {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  isActive      Boolean?    @default(true)
  targetScreen  String
  
  imageId       String      @db.ObjectId
  image         Media       @relation(fields: [imageId], references: [id], onDelete: Restrict)
}

model Brand {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  name          String      @unique
  description   String?
  isFeatured    Boolean     @default(false)

  logoId        String?     @db.ObjectId
  logo          Media?     @relation("BrandLogo", fields: [logoId], references: [id], onDelete: SetNull)

  // Relations
  products      Product[]
  categories    BrandCategory[]
}

model BrandCategory {
  id         String      @id @default(auto()) @map("_id") @db.ObjectId
  brandId    String   @db.ObjectId
  brand      Brand    @relation(fields: [brandId], references: [id], onDelete: Cascade)

  categoryId String   @db.ObjectId
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([brandId, categoryId]) // Ensure unique pairings
  @@index([brandId])
  @@index([categoryId])
}

model Product {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  slug          String?      
  description   String?
  originalPrice Float?       // Original price before any discounts
  salePrice     Float?      // Current selling price
  skuPrefix     String?
  isFeatured    Boolean     @default(false)
  isActive      Boolean     @default(true)
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  // Direct relationship to Brand (One-to-Many)
  brandId       String   @db.ObjectId
  brand         Brand    @relation(fields: [brandId], references: [id], onDelete: Cascade)

  // Relations
  images        ProductImage[]
  attributes    ProductAttribute[]
  categories    ProductCategory[]
  items         ProductItem[]
  tags          ProductTag[]

  @@index([brandId])
  @@index([name])
}

model ProductImage {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  isPrimary     Boolean     @default(false) // Indicates if this is the primary image for the product

  imageId       String      @db.ObjectId
  image         Media       @relation(fields: [imageId], references: [id], onDelete: Restrict)

  productId     String      @db.ObjectId
  product       Product     @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@unique([productId, imageId])
}

model ProductCategory {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId

  productId   String    @db.ObjectId
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  categoryId  String    @db.ObjectId
  category    Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([productId, categoryId]) // Ensure unique pairings
  @@index([productId])
  @@index([categoryId])
}

model Tag {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  name String @unique

  // Relations
  products ProductTag[]
}

// Join table for Product <-> Tag (Many-to-Many)
model ProductTag {
  id String @id @default(auto()) @map("_id") @db.ObjectId // Add primary key for Prisma

  productId String  @db.ObjectId
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  tagId     String  @db.ObjectId
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([productId, tagId])
  @@index([productId])
  @@index([tagId])
}

model AttributeType {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  name          String      @unique // e.g., "Color", "Size", "Material"
  description   String?

  // Relations
  productAttributes ProductAttribute[]
}

model ProductAttribute {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  value         String      // e.g., "Red", "Large", "Cotton"

  productId     String      @db.ObjectId
  product       Product     @relation(fields: [productId], references: [id], onDelete: Cascade)

  attributeTypeId String   @db.ObjectId
  attributeType AttributeType @relation(fields: [attributeTypeId], references: [id], onDelete: Cascade)

  // Relations
  productItems ProductItemAttribute[]

  @@unique([value, attributeTypeId, productId]) // Ensure a product doesn't have the same attribute value twice
  @@index([productId])
  @@index([attributeTypeId])
}

// Represents a specific stock-keeping unit (SKU) or variation of a Product
model ProductItem {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  sku           String?       // Unique SKU for this item
  stock         Int         @default(0)  // Available stock quantity
  originalPrice Float       // Can override the product's base price
  salePrice     Float       // Can override the product's sale price
  isFeatured    Boolean     @default(false)
  isActive      Boolean     @default(true)

  productId     String      @db.ObjectId
  product       Product     @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Relations
  // images        ProductImage[] // Optional: If you want to have images specific to this item
  orderItems    OrderItem[]
  attributes    ProductItemAttribute[] // Join table for attributes
  images        ProductItemImage[]
}

model ProductItemImage {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  isPrimary     Boolean     @default(false) // Indicates if this is the primary image for this specific item variation

  productItemId String      @db.ObjectId
  productItem   ProductItem @relation(fields: [productItemId], references: [id], onDelete: Cascade) // If item deleted, link deleted

  imageId       String      @db.ObjectId
  image         Media       @relation(fields: [imageId], references: [id], onDelete: Restrict) // Prevent Media deletion if used here

  @@unique([productItemId, imageId]) // Prevent linking the same image to the same item multiple times
  @@index([productItemId])
  @@index([imageId])
}

// Join table connecting a ProductItem to its specific ProductAttribute values
// e.g., ProductItem (T-Shirt SKU #123) links to ProductAttribute ("Color: Red") and ProductAttribute ("Size: L")
model ProductItemAttribute {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId

  productItemId String      @db.ObjectId
  productItem   ProductItem @relation(fields: [productItemId], references: [id], onDelete: Cascade)

  productAttributeId String   @db.ObjectId
  productAttribute ProductAttribute @relation(fields: [productAttributeId], references: [id], onDelete: Cascade)

  // Relations

  @@unique([productItemId, productAttributeId]) // Ensure a unique pairing
  @@index([productItemId])
  @@index([productAttributeId])
}

// --- Order Related Models ---

model OrderStatus {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  status          String    @unique // e.g., "Pending", "Processing", "Shipped", "Delivered", "Cancelled", "Returned"
  description   String?

  // Relations
  orders        Order[]
}

model Order {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  orderDate     DateTime    @default(now())
  deliveryDate  DateTime?   // Estimated or actual delivery date
  orderNumber   String      @unique // Unique order number
  totalAmount   Float       // Total amount for the order
  paymentStatus String?     // e.g., "Paid", "Pending", "Failed"
  transactionId  String?     // Reference to payment transaction ID
  shippingAddress Json      // snapshot of the shipping address at the time of order

  userId        String      @db.ObjectId
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  orderStatusId String      @db.ObjectId
  orderStatus   OrderStatus @relation(fields: [orderStatusId], references: [id], onDelete: Cascade)

  items         OrderItem[]

  @@index([userId])
  @@index([orderStatusId])
}

model OrderItem {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  quantity      Int         // Quantity of the product ordered
  price         Float       // Price *at the time of order* (snapshot)
  productName   String?     // Snapshot of the product name at the time of order
  productImage  String?     // Snapshot of the product image at the time of order
  productSku    String?     // Snapshot of the product SKU at the time of order

  orderId       String      @db.ObjectId
  order         Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productItemId String      @db.ObjectId
  productItem   ProductItem @relation(fields: [productItemId], references: [id], onDelete: Restrict)

  // Relations
  review       UserReview? 
  
  @@index([orderId])
  @@index([productItemId])
}

model UserReview {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  ratingValue   Int         // Rating value (1-5)
  comment       String?     
  reviewDate    DateTime    @default(now())

  userId        String      @db.ObjectId
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  orderItemId   String      @db.ObjectId @unique // Ensure a user can only review an order item once
  orderItem     OrderItem   @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@index([userId])
}

